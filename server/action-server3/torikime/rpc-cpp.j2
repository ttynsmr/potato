// Generated by the torikime.  DO NOT EDIT!
#include "rpc/rpc.h"
#include "session/session.h"
#include "rpc/payload.h"
#include "{{ contract }}_{{ name }}.h"

#include "{{ contract }}_{{ name }}.pb.h"
#include "meta.pb.h"
{% if "imports" in rpc -%}
{%- for import in imports %}
#include "{{ import }}.pb.h"
{%- endfor %}
{% endif %}

namespace {{ namespace }}::{{ contract }}::{{ name }}
{
{%- if "request" in rpc %}
	Responser::~Responser()
	{
		if (respond)
		{
			return;
		}

		send(false, {});
	}

	void Responser::send(bool success, {{ namespace }}::{{ contract }}::{{ name }}::Response&& response)
	{
		{{ namespace }}::{{ contract }}::{{ name }}::ResponseParcel responseParcel;
		responseParcel.set_request_id(_requestId);
		responseParcel.set_allocated_response(&response);
		responseParcel.set_success(success);

		potato::PayloadHeader header;
		header.set_contract_id({{ contract_id }});
		header.set_rpc_id({{ rpc_id }});
		header.set_meta(potato::Meta::RESPONSE);
		header.set_payload_size(responseParcel.ByteSize());

		std::shared_ptr<potato::net::protocol::Payload> payload = std::make_shared<potato::net::protocol::Payload>(header);
		responseParcel.SerializeToArray(payload->getPayloadData(), payload->getHeader().payload_size());
		responseParcel.release_response();

		_session->sendPayload(payload);

		respond = true;
	}
{% endif %}

{% if "notification" in rpc %}
	std::atomic<std::uint32_t> Rpc::_notificationId = 0;
{% endif %}

	Rpc::Rpc(std::shared_ptr<potato::net::Session> session) : _session(session)
	{
	}

{% if "request" in rpc %}
	void Rpc::on{{ name | camelize }}Request(const potato::net::protocol::Payload& payload)
	{
		{{ namespace }}::{{ contract }}::{{ name }}::RequestParcel requestParcel;
		deserialize(payload, requestParcel);

		auto responser = std::make_shared<Responser>(_session, requestParcel.request_id());
		_requestDelegate(_session, requestParcel, responser);
	}

	void Rpc::subscribeRequest(Rpc::RequestDelegate callback)
	{
		_requestDelegate = callback;
	}
{% endif %}

{% if "notification" in rpc %}
	std::shared_ptr<potato::net::protocol::Payload> Rpc::serializeNotification({{ namespace }}::{{ contract }}::{{ name }}::Notification& notification)
	{
		{{ namespace }}::{{ contract }}::{{ name }}::NotificationParcel notificationParcel;
		notificationParcel.set_allocated_notification(&notification);
		notificationParcel.set_notification_id(++_notificationId);

		potato::PayloadHeader header;
		header.set_contract_id({{ contract_id }});
		header.set_rpc_id({{ rpc_id }});
		header.set_meta(potato::Meta::NOTIFICATION);
		header.set_payload_size(notificationParcel.ByteSize());

		std::shared_ptr<potato::net::protocol::Payload> payload = std::make_shared<potato::net::protocol::Payload>(header);
		notificationParcel.SerializeToArray(payload->getPayloadData(), payload->getHeader().payload_size());
		notificationParcel.release_notification();
        return payload;
	}
{% endif %}

{%- if "request" in rpc %}
	void Rpc::deserialize(const potato::net::protocol::Payload& payload, {{ namespace }}::{{ contract }}::{{ name }}::RequestParcel& outRequest)
	{
		outRequest.Clear();
		outRequest.ParseFromArray(payload.getPayloadData(), payload.getHeader().payload_size());
	}
{% endif %}

{# {%- if "request" in rpc %} #}
	bool Rpc::receievePayload(const potato::net::protocol::Payload& payload)
	{
		switch (payload.getHeader().rpc_id())
		{
{%- if "request" in rpc %}
		case {{ rpc_id }}:
			on{{ name | camelize }}Request(payload);
			return true;
{% endif %}
        default:
            return false;
		}
	}
{# {% endif %} #}
}
